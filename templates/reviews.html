<!-- reviews.html -->
<!DOCTYPE html>
<html lang="en" class="light">
<!-- Head Section -->

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WordWise ‚Äî Reviews</title>

  <!-- Related Links -->
  <link rel="icon" type="image/png" href="/static/images/logo.jpg">
  <link rel="stylesheet" href="/static/css/style.css">
  <link href="https://cdn.jsdelivr.net/npm/remixicon/fonts/remixicon.css" rel="stylesheet">

  <!--Script Links -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Enable Tailwind dark mode -->
  <script>
    tailwind.config = { darkMode: 'class' }
  </script>

  <!-- style section -->
  <style>
    .logo-animate {
      transition: all 0.5s ease;
    }

    .logo-animate:hover {
      transform: rotate(360deg) scale(1.1);
      filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.9));
    }

    .star {
      font-size: 1.5rem;
      color: gray;
      cursor: pointer;
      transition: color 0.2s;
    }

    .star.selected,
    .star.hovered {
      color: #ec4899;
    }

    #reviewPanel {
      position: fixed;
      bottom: 80px;
      right: 20px;
      width: 350px;
      max-height: 70vh;
      background: rgba(255, 255, 255, 0.95);
      border-radius: 1rem;
      overflow-y: auto;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
      transition: transform 0.4s ease, opacity 0.4s ease;
      transform: translateY(120%);
      opacity: 0;
      z-index: 50;
    }

    body.dark #reviewPanel {
      background: rgba(31, 41, 55, 0.95);
    }

    #reviewPanel.show {
      transform: translateY(0);
      opacity: 1;
    }

    #toggleReviewPanel {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: #ec4899;
      color: white;
      font-weight: bold;
      border-radius: 9999px;
      padding: 12px 20px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      z-index: 51;
      transition: background 0.3s;
    }

    #toggleReviewPanel:hover {
      background: #db2777;
    }

    /* Make overlay not block other buttons */
    #offlineScreen {
      pointer-events: none;
      /* allow clicks through */
    }

    #dinoGame,
    #offlineScreen h1,
    #offlineScreen p {
      pointer-events: auto;
      /* only interactable elements */
    }
  </style>
</head>

<!-- Body Section -->

<body class="light min-h-screen flex flex-col">

  <!-- Navbar -->
  <nav id="navbar" class="bg-white/70 dark:bg-gray-900 shadow-md sticky top-0 z-50 transition-colors">
    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
      <div class="flex flex-wrap justify-between items-center py-3">

        <!-- Brand -->
        <a href="/home" class="flex items-center gap-2 group select-none mb-2 md:mb-0">
          <img src="/static/images/logo.jpg" alt="WordWise Logo"
            class="w-[clamp(32px,6vw,48px)] h-[clamp(32px,6vw,48px)] rounded-full logo-animate object-cover border-2 border-gray-300 dark:border-white" />
          <span class="text-[clamp(1.1rem,2vw,1.75rem)] font-extrabold tracking-tight">
            <span class="bg-clip-text text-transparent bg-gradient-to-r from-fuchsia-500 to-pink-500">Word</span>
            <span class="text-gray-900 dark:text-white">Wise</span>
          </span>
        </a>

        <!-- Desktop Nav Links -->
        <div class="hidden md:flex flex-wrap justify-center flex-1 gap-4 text-[clamp(0.9rem,1.3vw,1.1rem)]">
          <a href="/home" class="flex items-center gap-1 hover:text-pink-600"><i class="ri-home-2-line"></i>
            Home</a>
          <a href="/resource" class="flex items-center gap-1 hover:text-pink-600"><i class="ri-book-line"></i>
            Resources</a>
          <a href="/tools" class="flex items-center gap-1 hover:text-pink-600"><i class="ri-tools-line"></i>
            Tools</a>
          <a href="/blog" class="flex items-center gap-1 hover:text-pink-600"><i class="ri-file-text-line"></i>
            Blog</a>
          <a href="/about" class="flex items-center gap-1 hover:text-pink-600"><i class="ri-information-line"></i>
            About Us</a>
        </div>

        <div class="flex items-center gap-3">
          <button id="themeToggle"
            class="px-3 py-1 rounded-lg bg-pink-500 text-white hover:bg-pink-600 flex items-center gap-2">
            <i class="ri-moon-clear-line"></i> <span class="hidden sm:inline">Toggle</span>
          </button>

          <button id="menu-toggle" class="md:hidden text-3xl focus:outline-none">‚ò∞</button>
        </div>
      </div>
    </div>

    <div id="mobile-menu" class="hidden md:hidden flex-col gap-4 p-4 bg-white dark:bg-gray-900 shadow-md">
      <a href="/home" class="flex items-center gap-1 hover:text-pink-600"><i class="ri-home-2-line"></i> Home</a>
      <a href="/resource" class="flex items-center gap-1 hover:text-pink-600"><i class="ri-book-line"></i>
        Resources</a>
      <a href="/tools" class="flex items-center gap-1 hover:text-pink-600"><i class="ri-tools-line"></i> Tools</a>
      <a href="/blog" class="flex items-center gap-1 hover:text-pink-600"><i class="ri-file-text-line"></i> Blog</a>
      <a href="/about" class="flex items-center gap-1 hover:text-pink-600"><i class="ri-information-line"></i> About
        Us</a>
    </div>
  </nav>

  <script>
    document.getElementById("menu-toggle").addEventListener("click", () => {
      document.getElementById("mobile-menu").classList.toggle("hidden");
    });
  </script>

  <!-- Hero Section -->
  <section class="w-full flex flex-col items-center justify-center text-center py-12">
    <h1 class="text-4xl md:text-5xl font-extrabold mb-6"><span
        class="bg-clip-text text-transparent bg-gradient-to-r from-yellow-300 to-pink-500">WordWise</span>
      Reviews
    </h1>
  </section>

  <!-- Offline Middle Content -->
  <div id="offlineContainer" class="w-full max-w-3xl mx-auto my-4 px-4 sm:px-6">
    <div id="offlineScreen"
      class="flex flex-col items-center justify-center p-4 sm:p-6 bg-gray-100 dark:bg-gray-900 rounded-xl shadow-md hidden overflow-hidden">
      <h2 class="text-xl sm:text-2xl font-bold text-gray-800 dark:text-gray-200 mb-2 sm:mb-4 text-center">‚ö†Ô∏è Server
        Offline
      </h2>
      <p class="text-sm sm:text-base text-gray-600 dark:text-gray-400 mb-4 text-center">Connection lost... Play the Word
        Catcher!</p>

      <div class="relative w-full flex justify-center">
        <canvas id="dinoGame"
          class="max-w-full border rounded-lg bg-gradient-to-b from-blue-100 to-white dark:from-gray-800 dark:to-gray-900 shadow-inner block"></canvas>
      </div>

      <p class="text-[10px] sm:text-xs text-gray-500 dark:text-gray-400 mt-3 text-center">
        <span class="hidden sm:inline">Use LEFT / RIGHT Arrows to catch letters!</span>
        <span class="sm:hidden">Tap Left or Right side of the game area to move!</span>
      </p>
    </div>
  </div>



  <!-- Main Section -->
  <main class="flex-1 flex flex-col items-center justify-center p-6 gap-10">
    <div class="grid md:grid-cols-2 lg:grid-cols-3 gap-8 w-full max-w-6xl mt-4" id="reviewGridMain"></div>
  </main>

  <!-- Floating Review Panel -->
  <div id="reviewPanel">
    <div class="p-4">
      <h2 class="text-xl font-bold mb-4 text-gray-900 dark:text-white text-center">Quick Reviews</h2>
      <div id="latestReviews" class="space-y-2 text-sm mb-4"></div>

      <div class="mt-6 bg-white/90 dark:bg-gray-700 p-4 rounded-xl shadow">
        <h3 class="text-lg font-semibold mb-2 text-center">Submit Your Review</h3>
        <textarea id="reviewText" rows="3" placeholder="Write your review..."
          class="w-full p-2 mb-1 rounded-lg border border-gray-300 dark:border-gray-600 dark:bg-gray-800 dark:text-gray-100"></textarea>
        <p id="textError" class="text-red-500 text-xs hidden mb-1">Review text is required.</p>

        <div class="mb-2 text-center">
          <span class="star-submit star" data-value="1" aria-label="Rate 1 star">&#9733;</span>
          <span class="star-submit star" data-value="2" aria-label="Rate 2 stars">&#9733;</span>
          <span class="star-submit star" data-value="3" aria-label="Rate 3 stars">&#9733;</span>
          <span class="star-submit star" data-value="4" aria-label="Rate 4 stars">&#9733;</span>
          <span class="star-submit star" data-value="5" aria-label="Rate 5 stars">&#9733;</span>
        </div>
        <p id="ratingError" class="text-red-500 text-xs hidden mb-1">Please select a rating.</p>

        <button id="submitReview"
          class="bg-pink-500 text-white px-4 py-2 rounded-lg hover:bg-pink-600 w-full">Submit</button>
        <p id="submitMsg" class="text-green-500 text-sm hidden mt-2 text-center"></p>
      </div>
    </div>
  </div>

  <!-- Floating Button -->
  <button id="toggleReviewPanel">üí¨ Reviews</button>

  <!-- Main Script -->
  <script>
    // ===============================
    // THEME TOGGLE
    // ===============================
    const themeToggle = document.getElementById("themeToggle");
    const body = document.body;

    if (localStorage.getItem("theme") === "dark") {
      body.classList.add("dark");
      body.classList.remove("light");
    } else {
      body.classList.add("light");
      body.classList.remove("dark");
    }

    themeToggle.addEventListener("click", () => {
      body.classList.toggle("dark");
      body.classList.toggle("light");
      localStorage.setItem("theme", body.classList.contains("dark") ? "dark" : "light");
    });

    // ===============================
    // OFFLINE SCREEN & DINO GAME
    // ===============================
    // ===============================
    // OFFLINE SCREEN & WORD CATCHER GAME
    // ===============================
    const offlineScreen = document.getElementById("offlineScreen");
    const dinoCanvas = document.getElementById("dinoGame");
    const ctx = dinoCanvas.getContext("2d");

    // Game State
    let gameLoopId;
    let gameActive = false;
    let score = 0;
    let lives = 3;

    // Player (Owl)
    let playerX = 300;
    const playerWidth = 50;
    const playerHeight = 50;
    const playerSpeed = 8;
    let moveLeft = false;
    let moveRight = false;

    // Falling Letters
    let letters = [];
    const letterSpeedBase = 2;
    let spawnRate = 60; // frames
    let frameCount = 0;

    // Particles
    let particles = [];

    // Assets
    const owlImage = new Image();
    // Simple Owl SVG Data URI
    owlImage.src = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj4KICA8Y2lyY2xlIGN4PSI1MCIgY3k9IjUwIiByPSI0NSIgZmlsbD0iI2VjNDg5OSIgLz4KICA8Y2lyY2xlIGN4PSIzNSIgY3k9IjQwIiByPSIxMiIgZmlsbD0id2hpdGUiIC8+CiAgPGNpcmNsZSBjeD0iNjUiIGN5PSI0MCIgcj0iMTIiIGZpbGw9IndoaXRlIiAvPgogIDxjaXJjbGUgY3g9IjM1IiBjeT0iNDAiIHI9IjUiIGZpbGw9ImJsYWNrIiAvPgogIDxjaXJjbGUgY3g9IjY1IiBjeT0iNDAiIHI9IjUiIGZpbGw9ImJsYWNrIiAvPgogIDxwYXRoIGQ9Ik0gNTAgNjAgUSA2MCA3MCA1MCA4MCBRIDQwIDcwIDUwIDYwIiBmaWxsPSIjZmZjMTA3IiAvPgogIDxwYXRoIGQ9Ik0gMjAgNTAgUSAxMCAyMCAzMCAzMCIgZmlsbD0iIzRiNTU2MyIgLz4KICA8cGF0aCBkPSJNIDgwIDUwIFEgOTAgMjAgNzAgMzAiIGZpbGw9IiM0YjU1NjMiIC8+Cjwvc3ZnPg==";

    // Audio Context for Sound Effects
    let audioCtx = null;
    function initAudio() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }

    function playSound(type) {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);

      if (type === 'catch') {
        osc.type = 'sine';
        osc.frequency.setValueAtTime(800, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(1000, audioCtx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.1);
      } else if (type === 'miss') {
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(150, audioCtx.currentTime);
        osc.frequency.linearRampToValueAtTime(50, audioCtx.currentTime + 0.3);
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gain.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.3);
      } else if (type === 'gameover') {
        osc.type = 'square';
        osc.frequency.setValueAtTime(100, audioCtx.currentTime);
        osc.frequency.linearRampToValueAtTime(20, audioCtx.currentTime + 0.8);
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gain.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + 0.8);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.8);
      }
    }

    function resetGame() {
      score = 0;
      lives = 3;
      letters = [];
      particles = [];
      playerX = dinoCanvas.width / 2;
      gameActive = true;
      moveLeft = false;
      moveRight = false;
      spawnRate = 60;
      frameCount = 0;
      if (gameLoopId) cancelAnimationFrame(gameLoopId);
      gameLoop();
    }

    function createExplosion(x, y, color) {
      for (let i = 0; i < 8; i++) {
        particles.push({
          x: x,
          y: y,
          vx: (Math.random() - 0.5) * 6,
          vy: (Math.random() - 0.5) * 6,
          life: 1.0,
          color: color
        });
      }
    }

    function drawGame() {
      // Clear Canvas
      ctx.clearRect(0, 0, dinoCanvas.width, dinoCanvas.height);

      // Draw Player (Owl)
      // Draw centered at playerX
      ctx.drawImage(owlImage, playerX - playerWidth / 2, dinoCanvas.height - playerHeight - 10, playerWidth, playerHeight);

      // Draw Letters
      ctx.font = "bold 24px Arial";
      ctx.textAlign = "center";
      letters.forEach(l => {
        ctx.fillStyle = l.color;
        // Draw bubble background
        ctx.beginPath();
        ctx.arc(l.x, l.y - 8, 20, 0, Math.PI * 2);
        ctx.fillStyle = "white";
        ctx.fill();
        ctx.strokeStyle = l.color;
        ctx.lineWidth = 2;
        ctx.stroke();

        // Draw Letter
        ctx.fillStyle = l.color;
        ctx.fillText(l.char, l.x, l.y);
      });

      // Draw Particles
      particles.forEach(p => {
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.globalAlpha = 1.0;

      // Draw Lives Bars (Top Left)
      const barWidth = 30;
      const barHeight = 8;
      const barPadding = 5;
      for (let i = 0; i < 3; i++) {
        ctx.fillStyle = i < lives ? "#ec4899" : "rgba(128, 128, 128, 0.3)";
        ctx.beginPath();
        ctx.roundRect(20 + i * (barWidth + barPadding), 20, barWidth, barHeight, 4);
        ctx.fill();
      }

      // Draw Score and "Paused" text if not active
      ctx.fillStyle = document.body.classList.contains('dark') ? "#fff" : "#333";
      ctx.font = "bold 20px Arial";
      ctx.textAlign = "right";
      ctx.fillText("Score: " + score, dinoCanvas.width - 20, 30);

      if (!gameActive) {
        ctx.fillStyle = "rgba(0,0,0,0.6)";
        ctx.fillRect(0, 0, dinoCanvas.width, dinoCanvas.height);
        ctx.fillStyle = "white";
        ctx.textAlign = "center";

        if (lives <= 0) {
          ctx.font = "bold 32px Arial";
          ctx.fillText("GAME OVER!", dinoCanvas.width / 2, dinoCanvas.height / 2 - 20);
          ctx.font = "20px Arial";
          ctx.fillText("Final Score: " + score, dinoCanvas.width / 2, dinoCanvas.height / 2 + 20);
          ctx.font = "16px Arial";
          ctx.fillText("Press Arrow Keys to Try Again", dinoCanvas.width / 2, dinoCanvas.height / 2 + 55);
        } else {
          ctx.font = "24px Arial";
          ctx.fillText("Press Arrow Keys to Start", dinoCanvas.width / 2, dinoCanvas.height / 2);
        }
      }
    }

    function updateGame() {
      if (!gameActive) return;

      // Move Player
      if (moveLeft && playerX > playerWidth / 2) playerX -= playerSpeed;
      if (moveRight && playerX < dinoCanvas.width - playerWidth / 2) playerX += playerSpeed;

      // Spawn Letters
      frameCount++;
      if (frameCount % spawnRate === 0) {
        const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        const char = chars[Math.floor(Math.random() * chars.length)];
        const colors = ["#ec4899", "#3b82f6", "#10b981", "#f59e0b", "#8b5cf6"];
        letters.push({
          x: Math.random() * (dinoCanvas.width - 40) + 20,
          y: -20,
          char: char,
          speed: letterSpeedBase + Math.random() * 2,
          color: colors[Math.floor(Math.random() * colors.length)]
        });

        // Make it harder over time
        if (score > 10 && score % 5 === 0) spawnRate = Math.max(20, 60 - score);
      }

      // Update Letters
      for (let i = letters.length - 1; i >= 0; i--) {
        let l = letters[i];
        l.y += l.speed;

        // Collision Check (Simple distance)
        // Player hitbox is at (playerX, height-35) approx center
        const dx = playerX - l.x;
        const dy = (dinoCanvas.height - 35) - l.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < 40) { // Caught!
          score++;
          playSound('catch');
          createExplosion(l.x, l.y, l.color);
          letters.splice(i, 1);
        } else if (l.y > dinoCanvas.height + 20) {
          // Missed
          letters.splice(i, 1);
          lives--;
          if (lives <= 0) {
            playSound('gameover');
            gameActive = false;
            // Clear items for game over state
            letters = [];
          } else {
            playSound('miss');
          }
        }
      }

      // Update Particles
      for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life -= 0.05;
        if (p.life <= 0) particles.splice(i, 1);
      }
    }

    function gameLoop() {
      if (!gameActive && letters.length === 0) {
        drawGame(); // Draw initial state
        return;
      }

      updateGame();
      drawGame();
      if (gameActive) gameLoopId = requestAnimationFrame(gameLoop);
    }

    // Input Handling
    window.addEventListener("keydown", e => {
      if (e.target.matches("textarea, input")) return;
      initAudio(); // Initialize on first interaction

      if (e.key === "ArrowLeft") {
        moveLeft = true;
        if (!gameActive) resetGame();
      }
      if (e.key === "ArrowRight") {
        moveRight = true;
        if (!gameActive) resetGame();
      }
      if (e.key === " " || e.key === "Spacebar") {
        e.preventDefault(); // Prevent page scroll
        if (!gameActive) resetGame();
      }
    });

    window.addEventListener("keyup", e => {
      if (e.key === "ArrowLeft") moveLeft = false;
      if (e.key === "ArrowRight") moveRight = false;
    });

    function startDinoGame() {
      // Just draw the initial state, don't auto-reset
      if (!gameActive) {
        drawGame();
      }
    }

    // Resize Logic
    function resizeGameCanvas() {
      const container = document.getElementById("offlineContainer");
      if (!container) return;

      // Calculate available width
      const availableWidth = container.offsetWidth - (window.innerWidth < 640 ? 32 : 48);
      const width = Math.min(availableWidth, 600);

      // Maintain aspect ratio 2:1 for game logic, but allow scaling
      const height = width * 0.5;

      dinoCanvas.width = width;
      dinoCanvas.height = height;

      // Maintain player position ratio
      if (typeof playerX !== 'undefined') {
        const ratio = playerX / (dinoCanvas.width || width);
        playerX = width * ratio;
        if (playerX > width - playerWidth / 2) playerX = width - playerWidth / 2;
        if (playerX < playerWidth / 2) playerX = playerWidth / 2;
      }
    }

    // Touch Handling for Mobile
    dinoCanvas.addEventListener("touchstart", (e) => {
      e.preventDefault();
      initAudio();
      if (!gameActive) {
        resetGame();
        return;
      }
      const touch = e.touches[0];
      const rect = dinoCanvas.getBoundingClientRect();
      const x = touch.clientX - rect.left;

      if (x < rect.width / 2) {
        moveLeft = true;
        moveRight = false;
      } else {
        moveRight = true;
        moveLeft = false;
      }
    }, { passive: false });

    dinoCanvas.addEventListener("touchend", (e) => {
      e.preventDefault();
      moveLeft = false;
      moveRight = false;
    }, { passive: false });

    window.addEventListener("resize", () => {
      resizeGameCanvas();
      if (typeof drawGame === 'function') drawGame();
    });
    // Initial resize
    setTimeout(() => {
      resizeGameCanvas();
      if (typeof drawGame === 'function') drawGame();
    }, 100);

    // ===============================
    // REVIEW DATA HANDLING
    // ===============================
    const API_URL = "/reviews";
    const PENDING_KEY = "pendingReviews";
    let selectedRating = 0;
    let lastFetchedReviews = [];

    function loadPendingReviews() {
      return JSON.parse(localStorage.getItem(PENDING_KEY) || "[]");
    }

    function savePendingReview(review) {
      const pending = loadPendingReviews();
      pending.push(review);
      localStorage.setItem(PENDING_KEY, JSON.stringify(pending));
      renderLatestReviews();
    }

    function renderReviews(reviews) {
      const reviewGrid = document.getElementById("reviewGridMain");
      reviewGrid.innerHTML = "";
      reviews.forEach(r => {
        const div = document.createElement("div");
        div.className = "p-6 bg-white dark:bg-gray-800 rounded-xl shadow hover:shadow-lg transition flex flex-col gap-3";
        div.innerHTML = `
          <p class="font-semibold text-gray-900 dark:text-gray-100">${r.username || "Anonymous"}</p>
          <p class="text-gray-800 dark:text-gray-100">${r.text || ""}</p>
          <div class="flex gap-1 text-lg text-yellow-400">${"‚òÖ".repeat(r.stars || 0)}</div>
        `;
        reviewGrid.appendChild(div);
      });
    }

    function renderLatestReviews() {
      const latestDiv = document.getElementById("latestReviews");
      latestDiv.innerHTML = "";
      const pending = loadPendingReviews();
      const allReviews = [...lastFetchedReviews, ...pending];
      const latest = allReviews.slice(-5).reverse();

      latest.forEach(r => {
        const div = document.createElement("div");
        div.className = "p-2 bg-gray-100 dark:bg-gray-800 rounded-md shadow-sm flex flex-col";
        div.innerHTML = `
          <div class="flex justify-between">
            <span class="font-semibold text-gray-900 dark:text-gray-100">${r.username || "Anonymous"}</span>
            <span class="text-yellow-400">${"‚òÖ".repeat(r.stars || 0)}</span>
          </div>
          <p class="text-gray-700 dark:text-gray-300 text-sm mt-1">${r.text || ""}</p>
          ${r.status === "pending" ? `<span class="text-xs text-red-500 mt-1">Pending</span>` : ""}
        `;
        latestDiv.appendChild(div);
      });
    }

    async function fetchReviews() {
      try {
        const res = await fetch(API_URL);
        if (!res.ok) throw new Error("Fetch failed");
        const data = await res.json();
        lastFetchedReviews = data;

        if (gameInterval) { clearInterval(gameInterval); gameInterval = null; }
        gameStarted = false; gameOver = false;
        offlineScreen.style.display = "none";

        renderReviews(lastFetchedReviews); // only show server reviews on main grid
        renderLatestReviews();             // panel shows both fetched + pending
      } catch {
        offlineScreen.style.display = "flex";
        startDinoGame(); // Shows the "Press to Start" screen
        renderLatestReviews();
        setTimeout(fetchReviews, 5000); // Increased interval to be less aggressive
      }
    }

    async function syncPendingReviews() {
      const pending = loadPendingReviews();
      if (!pending.length) return;

      const successful = [];
      for (let review of pending) {
        try {
          const res = await fetch(API_URL, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(review)
          });
          if (res.ok) successful.push(review);
        } catch { }
      }

      if (successful.length) {
        const remaining = pending.filter(r => !successful.includes(r));
        localStorage.setItem(PENDING_KEY, JSON.stringify(remaining));
        renderLatestReviews();
        fetchReviews();
      }
    }

    // ===============================
    // STAR SELECTION & REVIEW SUBMIT
    // ===============================
    document.querySelectorAll(".star-submit").forEach(star => {
      star.addEventListener("click", () => {
        selectedRating = parseInt(star.dataset.value);
        document.querySelectorAll(".star-submit").forEach(s => {
          s.classList.toggle("selected", parseInt(s.dataset.value) <= selectedRating);
        });
      });
    });

    document.getElementById("submitReview").addEventListener("click", () => {
      const text = document.getElementById("reviewText").value.trim();
      const textError = document.getElementById("textError");
      const ratingError = document.getElementById("ratingError");
      const submitMsg = document.getElementById("submitMsg");

      textError.classList.add("hidden");
      ratingError.classList.add("hidden");
      submitMsg.classList.add("hidden");

      if (!text) { textError.classList.remove("hidden"); return; }
      if (!selectedRating) { ratingError.classList.remove("hidden"); return; }

      const review = { username: "Anonymous", text, stars: selectedRating, createdAt: new Date().toLocaleDateString(), status: "pending" };

      if (navigator.onLine) {
        fetch(API_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(review)
        }).then(res => {
          if (res.ok) {
            submitMsg.textContent = "Review submitted successfully!";
            submitMsg.classList.remove("hidden");
            document.getElementById("reviewText").value = "";
            selectedRating = 0;
            document.querySelectorAll(".star-submit").forEach(s => s.classList.remove("selected"));
            fetchReviews();
          } else savePendingReviewOffline();
        }).catch(savePendingReviewOffline);
      } else savePendingReviewOffline();

      function savePendingReviewOffline() {
        savePendingReview(review);
        submitMsg.textContent = "Saved offline. Will sync when online.";
        submitMsg.classList.remove("hidden");
      }
    });

    // ===============================
    // ONLINE EVENT
    // ===============================
    window.addEventListener("online", () => {
      syncPendingReviews();
      if (gameInterval) { clearInterval(gameInterval); gameInterval = null; }
      resetGame();
      gameStarted = false;
      gameOver = false;
      offlineScreen.style.display = "none";
      fetchReviews();
    });

    // ===============================
    // REVIEW PANEL TOGGLE
    // ===============================
    const reviewPanel = document.getElementById("reviewPanel");
    document.getElementById("toggleReviewPanel").addEventListener("click", () => {
      reviewPanel.classList.toggle("show");
    });

    // ===============================
    // INITIAL LOAD
    // ===============================
    fetchReviews();
    syncPendingReviews();
  </script>
</body>

</html>